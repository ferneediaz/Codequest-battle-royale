{
  "id": "number-of-islands",
  "title": "Number of Islands",
  "description": "Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
  "difficulty": "medium",
  "category": "Graph Adventures",
  "starterCode": {
    "javascript": "/**\n * @param {character[][]} grid\n * @return {number}\n */\nfunction numIslands(grid) {\n  // Your code here\n}",
    "python": "def num_islands(grid):\n    \"\"\"\n    :type grid: List[List[str]]\n    :rtype: int\n    \"\"\"\n    # Your code here\n    pass"
  },
  "solutionCode": {
    "javascript": "/**\n * @param {character[][]} grid\n * @return {number}\n */\nfunction numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n  \n  const rows = grid.length;\n  const cols = grid[0].length;\n  let count = 0;\n  \n  // Function to perform DFS\n  function dfs(i, j) {\n    // Check boundary conditions and if current cell is land\n    if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] === '0') {\n      return;\n    }\n    \n    // Mark current cell as visited by changing it to '0'\n    grid[i][j] = '0';\n    \n    // Explore all four directions\n    dfs(i + 1, j); // down\n    dfs(i - 1, j); // up\n    dfs(i, j + 1); // right\n    dfs(i, j - 1); // left\n  }\n  \n  // Traverse the grid\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === '1') {\n        count++;\n        dfs(i, j);\n      }\n    }\n  }\n  \n  return count;\n}",
    "python": "def num_islands(grid):\n    if not grid or len(grid) == 0:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    count = 0\n    \n    # Function to perform DFS\n    def dfs(i, j):\n        # Check boundary conditions and if current cell is land\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == '0':\n            return\n        \n        # Mark current cell as visited by changing it to '0'\n        grid[i][j] = '0'\n        \n        # Explore all four directions\n        dfs(i + 1, j)  # down\n        dfs(i - 1, j)  # up\n        dfs(i, j + 1)  # right\n        dfs(i, j - 1)  # left\n    \n    # Traverse the grid\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n    \n    return count"
  },
  "constraints": [
    "m == grid.length",
    "n == grid[i].length",
    "1 <= m, n <= 300",
    "grid[i][j] is '0' or '1'."
  ],
  "examples": [
    "Example 1:\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1",
    "Example 2:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3"
  ],
  "testCases": [
    {
      "input": "[[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
      "output": "1",
      "isHidden": false
    },
    {
      "input": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
      "output": "3",
      "isHidden": false
    },
    {
      "input": "[[\"1\"]]",
      "output": "1",
      "isHidden": false
    },
    {
      "input": "[[\"0\"]]",
      "output": "0",
      "isHidden": false
    },
    {
      "input": "[[\"1\",\"0\",\"1\",\"0\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"0\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\"]]",
      "output": "9",
      "isHidden": true
    },
    {
      "input": "[[\"1\",\"1\",\"1\"],[\"0\",\"1\",\"0\"],[\"1\",\"1\",\"1\"]]",
      "output": "1",
      "isHidden": true
    }
  ],
  "timeLimit": 1000,
  "memoryLimit": 128000
}